#' ---
#' title: "Earth Hologenome Initiative final report"
#' author: "`r params$batch`"
#' output:
#'   pdf_document:
#'     toc: true
#'     latex_engine: xelatex
#' header-includes:
#'   - \usepackage{fontspec}
#'   - \setmainfont{Arial}
#' params:
#'   batch: NULL
#'   count_file: NULL
#'   coverage_file: NULL
#'   sample_file: NULL
#'   mags_file: NULL
#'   tree_file: NULL
#'   kegg_file: NULL
#' ---

#' \newpage
#' # Introduction
#' This is the report automatically generated by the Earth Holohenome Initiative bioinformatic pipeline.
#' Here you will find basic information of the dataset, which aims to guide you in assessing whether data
#' quality is good enough, whether more sequencing is needed, as well as formulating downstream statistical analyses.
#' Note that the analyses and visualisations displayed here are not study-specific, so they are not intended to serve
#' as conclusive analyses.

#' The reporting is still in developmental phase.


#+ load_libraries, echo=FALSE, warning=FALSE
#Load libraries and data
suppressPackageStartupMessages(library(knitr))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(ape))
suppressPackageStartupMessages(library(phytools))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(ggtree))
suppressPackageStartupMessages(library(ggrepel))
suppressPackageStartupMessages(library(ggpubr))
suppressPackageStartupMessages(library(ggnewscale))
suppressPackageStartupMessages(library(ggtreeExtra))
suppressPackageStartupMessages(library(gridExtra))
suppressPackageStartupMessages(library(hilldiv2))
suppressPackageStartupMessages(library(spaa))
suppressPackageStartupMessages(library(vegan))
suppressPackageStartupMessages(library(Rtsne))

#+ load_data, echo=FALSE, warning=FALSE
# Load all files produced by the EHI pipeline
batch <- params$batch
mags_table <- read.table(params$mags_file,sep="\t",header=T)
rownames(mags_table) <- mags_table[,1]

count_table <- read.table(params$count_file,sep="\t",row.names=1,header=T)
count_table <- count_table[mags_table$genome,]

coverage_table <- read.table(params$coverage_file,sep="\t",row.names=1,header=T)
coverage_table <- coverage_table[mags_table$genome,]

sample_table <- read.table(params$sample_file,sep="\t",header=T) %>%
    rename(sample=EHI_plaintext)

tree <- read.tree(params$tree_file) %>%
    keep.tip(tip=mags_table$genome)


if(file.exists(params$kegg_file)){
    func = "yes"
    kegg_table <- read.table(params$kegg_file,sep="\t",header=T, row.names=1)
}else{
    func = "no"
}
#+ load_colors, echo=FALSE, warning=FALSE
# Load EHI taxonomy colours
colours_URL="https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv"
download.file(colours_URL, "ehi_phylum_colors.tsv")
ehi_phylum_colors <- read.table("ehi_phylum_colors.tsv",sep="\t",header=T,comment.char = "")

#' # Data availability
#' The data used for generating this report is available through the following links:\newline
#' **Count table**\newline
#' \color{cyan}
#' https://sid.erda.dk/share_redirect/BaMZodj9sA/DMB/`r paste0(batch,"/",batch)`_counts.tsv.gz \color{black}
#' \newline
#' It contains the read-count table specifying how many reads mapped to which MAG in each sample. This table is used for quantifying MAGs.\newline
#' \newline
#' **Coverage table**\newline
#' \color{cyan}
#' https://sid.erda.dk/share_redirect/BaMZodj9sA/DMB/`r paste0(batch,"/",batch)`_coverage.tsv.gz \color{black}
#' \newline
#' It contains the breadth of coverage values for each MAG in each sample. This table is used for filtering MAGs.\newline
#' \newline
#' **Sample metadata**\newline
#' \color{cyan}
#' https://sid.erda.dk/share_redirect/BaMZodj9sA/DMB/`r paste0(batch,"/",batch)`_metadata.tsv.gz \color{black}
#' \newline
#' It contains the basic metadata of each sample, including host species, location, sample type and similar.\newline
#' \newline
#' **MAG metadata**\newline
#' \color{cyan}
#' https://sid.erda.dk/share_redirect/BaMZodj9sA/DMB/`r paste0(batch,"/",batch)`_mag_info.tsv.gz \color{black}
#' \newline
#' It contains the structural, taxonomic and quality information of all MAGs. It is used for MAG filtering and visualisations.\newline
#' \newline
#' **MAG phylogenetic tree**\newline
#' \color{cyan}
#' https://sid.erda.dk/share_redirect/BaMZodj9sA/DMB/`r paste0(batch,"/",batch)`.tree.gz \color{black}
#' \newline
#' It contains the phylogenetic tree of all MAGs. It is used for phylogenetic diversity analyses and visualisations.\newline
#' \newline
#' **MAG funcion table**\newline
#' \color{cyan}
#' https://sid.erda.dk/share_redirect/BaMZodj9sA/DMB/`r paste0(batch,"/",batch)`_merged_kegg.tsv.gz \color{black}
#' \newline
#' It contains the distilled KEGG pathway fullness values for all MAGs. It is used for functional diversity analyses and visualisations.
#' \newpage

#+ generate_stats, echo=FALSE, warning=FALSE
nsamples <- ncol(count_table)
metagenomic_bases <- sum(sample_table$metagenomic_bases)
host_bases <- sum(sample_table$host_bases)
discarded_bases <- sum(round(((sample_table$metagenomic_bases+sample_table$host_bases)/(1-sample_table$bases_lost_fastp_percent))-(sample_table$metagenomic_bases+sample_table$host_bases)))
total_bases <- discarded_bases + host_bases + metagenomic_bases
singlem_bases <- sum(sample_table$metagenomic_bases * sample_table$singlem_fraction)
nmags <- nrow(count_table)
new_species <- mags_table %>%
	filter(species == "s__") %>%
	nrow()

sequencing_depth <- colSums(count_table)
sequencing_depth_sum <- sum(sequencing_depth)
sequencing_depth_mean <- mean(sequencing_depth)
sequencing_depth_sd <- sd(sequencing_depth)

#' # 1. General overview
#' ## 1.1 Produced data
#' **Number of samples:** `r paste0(nsamples,"\n")`
#' **Amount of total data:** `r paste0(round(total_bases / 1000000000,2)," GB \n")`
#' \scriptsize
#' The amount of total DNA data sequenced in gigabases (GB, one billion nucleotide bases). As a reference,
#' the amount of data processed in this batch is equivalent to `r paste0(round(total_bases / 3100000000,2)," human genomes.")`
#' \normalsize\newline
#'
#' **Amount of discarded data:** `r paste0(round(discarded_bases / 1000000000,2)," GB ")`
#' `r paste0("(",round(discarded_bases / total_bases * 100,2)," % of the raw data)\n")`
#' \scriptsize
#' The amount of data discarded due to low quality or lack of informativeness during data preprocesing.
#' Discarding 5-15% of the produced data is within the expected range, due to formation of adaptor dimers,
#' inclusion of adaptors in sequencing reads due to short insert sizes, low sequencing quality, etc.
#' \normalsize\newline
#'
#' **Amount of host data:** `r paste0(round(host_bases / 1000000000,2)," GB ")`
#' `r paste0("(",round(host_bases / (total_bases-discarded_bases) * 100,2)," % of the quality-filtered data)\n")`

#' \scriptsize
#' The amount of data mapped against the host genome. The percentage refers to the amount of data mapped
#' to the host genome respect to quality-filtered data. Note that this value can be very variable depending
#' on the biological features of the sample (e.g., anal swabs contain more host DNA than faeces) and the
#' employed reference genome (e.g., the chances for mapping to the genome are lower as the distance between)
#' the study species and the employed reference genome differ).
#' \normalsize\newline
#'
#' **Amount of metagenomic data:** `r paste0(round(metagenomic_bases / 1000000000,2)," GB ")`
#' `r paste0("(",round(metagenomic_bases / (total_bases-discarded_bases) * 100,2)," % of the quality-filtered data)\n")`

#' \scriptsize
#' The amount of data not-mapped against the host genome. Note that this fraction does not only include
#' the prokaryotic DNA that we intend to reconstruct into MAGs, but also dietary DNA, viruses, etc., which
#' which will not map against the MAG catalogue.
#' \normalsize\newline
#'
#' **Estimated prokaryotic data:** `r paste0(round(singlem_bases / 1000000000,2)," GB ")`
#' `r paste0("(",round(singlem_bases / (metagenomic_bases) * 100,2)," % of the metagenomic data)\n")`

#' \scriptsize
#' The amount and proportion of data belonging to prokayotic genomes respect to the total metagenomic fraction,
#' as estimated from singleM analysis. Note that this is an estimation that relies on the
#' genome sizes of genomes available in reference databases. If a given taxon
#' is not properly represented, genome size estimations can be less accurate.
#' \normalsize\newline
#'
#' **Number of MAGs:** `r paste0(nmags,"\n")`
#' Out of which `r paste0(new_species," (",round(new_species / nmags*100,1),"%) are new species\n")`

#' \scriptsize
#' The number of metagenome-assembled genomes (MAG) or draft bacterial genomes reconstructed from the metagenomic data.
#' \normalsize\newline
#'
#' **Total mapped sequencing depth:** `r paste0(round(sequencing_depth_sum / 1000000,2)," million reads ")`
#' `r paste0("(",round(sequencing_depth_sum / 1000000000 * 143,2)," GB)\n")`
#' \scriptsize
#' The amount of reads (and nucleotide bases) that were mapped to the entire MAG catalogue. Note that the amount of bases is
#' only an approximation estimated by multiplying the exact number of mapped reads by 250 bp.
#' \normalsize\newline
#'
#' **Average mapped sequencing depth:** `r paste0(round(sequencing_depth_mean / 1000000,2),"&plusmn;",round(sequencing_depth_sd/1000000,2)," million reads ")`
#' `r paste0("(",round(sequencing_depth_mean / 1000000000 * 143,2),"&plusmn;",round(sequencing_depth_sd/1000000000 * 300,2)," GB)\n")`
#' \scriptsize
#' This is the average number of reads (and nucleotide bases) mapped to each sample. Note that the amount of bases is
#' only an approximation estimated by multiplying the exact number of mapped reads by 250 bp.
#' \normalsize\newline
#'
#' \newpage
#' ## 1.2 Sample metadata
#' The samples processed in this batch were collected in the following locations:
#+ sample_map_frame, echo=FALSE, warning=FALSE
#Calculate map frame
maxlat <- max(sample_table$latitude)+10
minlat <- min(sample_table$latitude)-10
maxlon <- max(sample_table$longitude)+10
minlot <- min(sample_table$longitude)-10

#+ sample_summary, echo=FALSE, warning=FALSE, results='hide'
#Summaryse for map
options(dplyr.summarise.inform = FALSE)
sample_table_summary <- sample_table %>%
  #Group by geography and count samples
  select(sample, latitude, longitude, country) %>%
  group_by(latitude, longitude) %>%
  summarize(count = n()) %>%
  ungroup()

#+ sample_map, echo=FALSE, warning=FALSE, fig.height=4, fig.cap = "Geographic location of samples. Size indicates the number of samples."
  #Print world map
  sample_table_summary %>%
  ggplot(.) +
    geom_map(
      data=map_data("world"),
      map = map_data("world"),
      aes(long, lat, map_id=region),
      color = "white", fill = "#cccccc", size = 0.2
    ) +
    #Crop map
    #coord_sf(xlim = c(minlot, maxlon), ylim = c(minlat, maxlat), expand = FALSE) +
    geom_point(
      aes(x=longitude,y=latitude, size=count),
      alpha=0.5, shape=16) +
    theme_minimal() +
    theme(legend.position = "none",
        axis.title.x=element_blank(),
        axis.title.y=element_blank()
      )

#+ sample_table, echo=FALSE, warning=FALSE
#Sample table
sample_table %>%
  select(sample,sample_type,country,latitude,longitude) %>%
  kable()

#'
#' \newpage
#' # 2 MAG catalogue
#'
#' ## 2.1 Phylogenetic tree
#' The phylogenetic tree is constructed by placing the MAG sequences within the reference archaeal
#' and bacterial trees using GTDBTK, followed by merging both trees. The external grey ring indicates genome sizes of the MAGs,
#' while the middle ring shows an overview of completeness (height) and contamination (green = low, red = high).
#' The original tree can be downloaded here:
#' **[Phylogenetic tree file](https://sid.erda.dk/share_redirect/BaMZodj9sA/DMB/`r params$batch`/`r params$batch`.tree.gz).**

#+ list_phyla, echo=FALSE, warning=FALSE
phyla <- ehi_phylum_colors %>%
  right_join(mags_table, by=join_by(phylum == phylum)) %>%
	arrange(match(genome, tree$tip.label)) %>%
  select(phylum, colors) %>%
	unique()

mag_sizes <- mags_table %>%
		  select(c(genome,mag_size)) %>%
		  mutate(mag_size=round(mag_size/1000000,2))

mag_completeness <- mags_table %>%
		 select(c(genome,completeness)) %>%
		 as.data.frame() %>%
		 remove_rownames() %>%
		 column_to_rownames(var = "genome")

#+ circular_tree_prep, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide"
heatmap <- ehi_phylum_colors %>%
  right_join(mags_table, by=join_by(phylum == phylum)) %>%
	arrange(match(genome, tree$tip.label)) %>%
  select(genome,phylum) %>%
	mutate(phylum = factor(phylum, levels = unique(phylum))) %>%
	column_to_rownames(var = "genome")

colors_alphabetic <- ehi_phylum_colors %>%
  right_join(mags_table, by=join_by(phylum == phylum)) %>%
	arrange(match(genome, tree$tip.label)) %>%
  select(phylum, colors) %>%
	unique() %>%
	arrange(phylum) %>%
	select(colors) %>%
	pull()

#Baseline tree
circular_tree <- force.ultrametric(tree,method="extend") %>%
	ggtree(., layout = 'circular', size = 0.3, angle=45)

#Add phylum colors ring
circular_tree <- gheatmap(circular_tree, heatmap, offset=0.85, width=0.1, colnames=FALSE) +
		scale_fill_manual(values=colors_alphabetic) +
		geom_tiplab2(size=1, hjust=-0.1) +
		theme(legend.position = "none", plot.margin = margin(0, 0, 0, 0), panel.margin = margin(0, 0, 0, 0))

#Add completeness ring
circular_tree <- circular_tree + new_scale_fill()
#circular_tree <-	gheatmap(circular_tree, mag_completeness, offset=0.85, width=0.1, colnames=FALSE) +
#			scale_fill_gradient(low = "#fde7a1", high = "#003a73") +
#			theme(legend.position = "none", plot.margin = margin(0, 0, 0, 0), panel.margin = margin(0, 0, 0, 0))

circular_tree <-  circular_tree +
							new_scale_fill() +
							scale_fill_gradient(low = "#d1f4ba", high = "#f4baba") +
							geom_fruit(
					         data=mags_table,
					         geom=geom_bar,
					         mapping = aes(x=completeness, y=genome, fill=contamination),
									 offset = 0.55,
									 orientation="y",
			             stat="identity",
					     )


#Add genome-size ring
circular_tree <-  circular_tree +
				new_scale_fill() +
				scale_fill_manual(values = "#cccccc") +
				geom_fruit(
		         data=mag_sizes,
		         geom=geom_bar,
		         mapping = aes(x=mag_size, y=genome),
						 offset = 0.05,
						 orientation="y",
             stat="identity",
		     )

#+ circular_tree_plot, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=6
#Plot complete chart
circular_tree

#+ phyla_colors, echo=FALSE, warning=FALSE, fig.height=1.5
phyla_legend <- ehi_phylum_colors %>%
  right_join(mags_table, by=join_by(phylum == phylum)) %>%
	arrange(match(genome, tree$tip.label)) %>%
  select(phylum, colors) %>%
	unique() %>%
	mutate(phylum = gsub("p__","",phylum)) %>%
  mutate(phylum = factor(phylum, levels = phylum)) %>%
	ggplot() +
	  geom_blank() +
	  geom_rect(aes(xmin = 1:(nrow(phyla)) - 0.5, xmax = 1:(nrow(phyla)) + 0.5, ymin = 0.19, ymax = 0.2, fill = phylum)) +
		scale_fill_manual(values=rev(phyla$colors)) +
	  geom_text(aes(x = 1:(nrow(phyla)), y = 0.15, label = rev(phylum)), angle = 90, hjust = 0, size = 3) +
	  theme_void() +
	  theme(legend.position = "none")

phyla_legend

#' \newpage
#' ## 2.2 Quality of MAGs
#' The two main parameters to assess the quality of reconstructed MAG as completeness and contamination (or redundancy).
#' These parameters are calculated by CheckM based on the presence of single-copy core genes in the MAGs. Completeness values
#' should ideally be as close to 100 as possible, because incompleteness introduces biases when performing functional analyses.
#' Contamination should be as close to 0 as possible, because it indicates that the MAG probably contains DNA fragments that
#' in reality belong to a different genome, and therefore can distort the results and introduce noise. In the below plot, MAGs
#' are ordinated according to their completeness and contamination scores, while dot sizes indicate their genome-size.
#' The following page(s) contain(s) an overview of these values for every MAG, while the the complete MAG feature table can be downloaded here:
#' **[MAG feature table file](https://sid.erda.dk/share_redirect/BaMZodj9sA/DMB/`r params$batch`/`r params$batch`_mag_info.tsv.gz)**
#+ calculate_mag_stats, echo=FALSE, warning=FALSE

#Prepare table for the visualisations
mag_details <- mags_table %>%
  select(c(genome,domain,phylum,completeness,contamination,mag_size)) %>%
  mutate(mag_size=round(mag_size/1000000,2)) %>% #change mag_size to MBs
  rename(comp=completeness,cont=contamination,size=mag_size) %>% #rename columns
  remove_rownames() %>%
  arrange(match(genome, rev(tree$tip.label))) #sort MAGs according to phylogenetic tree

#Create biplot with dot sizes indicating MAG size
mag_stats_biplot <- mag_details %>%
		ggplot(aes(x=comp,y=cont,size=size,color=phylum)) +
		      geom_point(alpha=0.7) +
					ylim(c(10,0)) +
					scale_color_manual(values=colors_alphabetic) +
				labs(y= "Contamination", x = "Completeness") +
					theme_classic() +
				  theme(legend.position = "none")

#Contamination boxplot
mag_stats_cont <- mag_details %>%
			ggplot(aes(y=cont)) +
					ylim(c(10,0)) +
					geom_boxplot(colour = "#999999", fill="#cccccc") +
					theme_void() +
					theme(legend.position = "none",
						axis.title.x = element_blank(),
						axis.title.y = element_blank(),
						axis.text.y=element_blank(),
			      axis.ticks.y=element_blank(),
						axis.text.x=element_blank(),
			      axis.ticks.x=element_blank(),
						plot.margin = unit(c(0, 0, 0.40, 0),"inches")) #add bottom-margin (top, right, bottom, left)

#Completeness boxplot
mag_stats_comp <-mag_details %>%
		ggplot(aes(x=comp)) +
				xlim(c(50,100)) +
				geom_boxplot(colour = "#999999", fill="#cccccc") +
				theme_void() +
				theme(legend.position = "none",
					axis.title.x = element_blank(),
					axis.title.y = element_blank(),
					axis.text.y=element_blank(),
		      axis.ticks.y=element_blank(),
					axis.text.x=element_blank(),
		      axis.ticks.x=element_blank(),
					plot.margin = unit(c(0, 0, 0, 0.50),"inches")) #add left-margin (top, right, bottom, left)

#+ plot_mag_stats, echo=FALSE, warning=FALSE, fig.height=5
#Arrage the biplot and the boxplots properly
grid.arrange(grobs = list(mag_stats_comp,mag_stats_biplot,mag_stats_cont),
		layout_matrix = rbind(c(1,1,1,1,1,1,1,1,1,1,1,4),
													c(2,2,2,2,2,2,2,2,2,2,2,3),
													c(2,2,2,2,2,2,2,2,2,2,2,3),
													c(2,2,2,2,2,2,2,2,2,2,2,3),
													c(2,2,2,2,2,2,2,2,2,2,2,3),
													c(2,2,2,2,2,2,2,2,2,2,2,3),
													c(2,2,2,2,2,2,2,2,2,2,2,3),
													c(2,2,2,2,2,2,2,2,2,2,2,3),
													c(2,2,2,2,2,2,2,2,2,2,2,3),
													c(2,2,2,2,2,2,2,2,2,2,2,3),
													c(2,2,2,2,2,2,2,2,2,2,2,3),
													c(2,2,2,2,2,2,2,2,2,2,2,3)))

#' \newpage
#+ plot_mag_table, echo=FALSE, warning=FALSE
  kable(mag_details)

#' \newpage
#' ## 2.3 Functional attributes of MAGs
#' Prokaryotic genomes carry different sets of genes that confer their organisms with different functional capabilities.
#' By annotating the microbial genes against the KEGG catalogue, enables calculating how full each of the hundreds of
#' metabolic functions is in each genome, and in this way infer functional capabilities of each strain. The below figure
#' shows the MAG phylogenetic tree associated with fullness (between 0-1) levels for each metabolic pathway.
#' `r if(func == "no"){paste0("\n\nThis analysis was skipped because no functional data was inputed.\n")}`
#+ kegg_heatmap, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=6

if(func == "yes"){
	kegg_tree <- force.ultrametric(tree,method="extend") %>%
				ggtree(., size = 0.3)

	#Add phylum colors
	kegg_tree <- gheatmap(kegg_tree, heatmap, offset=0, width=0.1, colnames=FALSE) +
			scale_fill_manual(values=colors_alphabetic)

	#Reset fill scale
	kegg_tree <- kegg_tree + new_scale_fill()

	#Add KEGG heatmap
	kegg_tree <- gheatmap(kegg_tree, kegg_table, offset=0.5, width=3.5, colnames=FALSE) +
			vexpand(.08) +
			coord_cartesian(clip = "off") +
			scale_fill_gradient(low = "#f4f4f4", high = "steelblue", na.value="white")

	#Plot tree + heatmap
	kegg_tree +
			theme(legend.position='none')
}

#' \newpage
#' ## 2.4 Functional ordination of MAGs
#' Using the functional annotation, it is possible to ordinate prokaryotic genomes on a bidimentional space. In doing so,
#' one can assess how close any group of bacteria are in functional terms, or how functionally diverse the members of a given
#' phylum can be.
#' `r if(func == "no"){paste0("\n\nThis analysis was skipped because no functional data was inputed.\n")}`
#+ mag_tsne, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=6
if(func == "yes"){
	#Calculat tSNE coordinates
	tryCatch({
		tSNE_func <- Rtsne(X=kegg_table, dims = 2, check_duplicates = FALSE)
 	}, error = function(e) {
 	})
	#Plot tSNE (only if the Rtsne function is successful)
	if(exists("tSNE_func")){
					tSNE_func$Y %>%
						  as.data.frame() %>%
						  mutate(genome=rownames(kegg_table)) %>%
						  inner_join(mags_table, by="genome") %>%
							rename(tSNE1="V1", tSNE2="V2") %>%
							select(genome,phylum,tSNE1,tSNE2, completeness) %>%
						    ggplot(aes(x = tSNE1, y = tSNE2, color = phylum, size=completeness))+
						    geom_point(shape=16, alpha=0.7) +
						    scale_color_manual(values=colors_alphabetic) +
						    theme_minimal() +
						    theme(legend.position = "none")
		} else {
			print("Functional ordination could not be created due to lack of sufficient data.\n")

		}
}

#+ phyla_colors2, echo=FALSE, warning=FALSE, fig.height=1.5
if(func == "yes" && exists("tSNE_func")){
	phyla_legend
}

#' \newpage
#' # 3. Sequencing depth assessment
#' ## 3.1 DNA fractions
#' When performing genome-resolved metagenomic analyses on host-associated microbial communities, the data usually contains a mixture of origins.
#' One fraction is low-quality data that is discarded in the bioinformatic preprocessing due to lack of informativeness. These data include low-quality
#' bases, adaptors, low-complexity reads and alike, which do not contribute to the study. Another fraction belongs to the host genome against which the
#' data are mapped. The host fraction can be very variable depending on the species and the sample type, and while it is not informative for metagenomic
#' analyses, it can be used for genomic analyses. The rest is what we call the metagenomic fraction. Part of the metagenomic fraction is built into draft
#' bacterial genomes or MAGs, against which metagenomic reads are mapped later on to quantify relative representation of genomes. The fraction that is not
#' built into MAGs is what is also unmapped against the MAG catalogue. This last fraction includes DNA dietary items, viruses and other organisms, but can values_to
#' include prokaryotic DNA of bacteria and archaea that were unable to be reconstructed.

#' In order to have representative results, the number of reads mapped to the MAG catalogue should be
#' similar across samples. However, multiple reasons can create large imbalances,
#' including uneven sequencing depth, different microbiome complexity across samples,
#' different amount of host or non-microbial reads in the dataset, etc.
#' The following plot shows the distribution of reads across samples.
#+ echo=FALSE, warning=FALSE


if(sequencing_depth_sd > sequencing_depth_mean){
  seqwarning <- TRUE
}else{
  seqwarning <- FALSE
}

#' `r ifelse(seqwarning, "> **Warning**: Sequencing depth is very uneven across samples", "")`

#+ data_fraction, echo=FALSE, warning=FALSE
# Calculate sequence fractions
sequence_fractions <- count_table %>%
  rownames_to_column("Genome") %>%
  pivot_longer(-Genome, names_to = "sample", values_to = "value") %>%
  group_by(sample) %>%
  summarise(mags = sum(value)) %>%
	left_join(sample_table, by = join_by(sample == sample))  %>%
	select(sample,mags,metagenomic_bases,host_bases,bases_lost_fastp_percent) %>%
	mutate(mags_bases = mags*146) %>%
	mutate(lowqual_bases = ((metagenomic_bases+host_bases)/(1-bases_lost_fastp_percent))-(metagenomic_bases+host_bases)) %>%
	mutate(unmapped_bases = metagenomic_bases - mags_bases) %>%
	mutate(unmapped_bases = ifelse(unmapped_bases < 0, 0, unmapped_bases)) %>%
	select(sample,mags_bases,unmapped_bases,host_bases,lowqual_bases)

mags_bases_mean <- sequence_fractions %>%
	mutate(mags_bases = mags_bases / 1000000000) %>%
	select(mags_bases) %>%
	pull() %>%
	mean()

#+ data_fraction_barplot, echo=FALSE, warning=FALSE, fig.height=5
sequence_fractions %>%
	pivot_longer(!sample, names_to = "fraction", values_to = "value") %>%
	mutate(value = value / 1000000000) %>%
	mutate(fraction = factor(fraction, levels = c("lowqual_bases","host_bases","unmapped_bases","mags_bases"))) %>%
	ggplot(., aes(x = sample, y = value, fill=fraction)) +
	    geom_bar(position="stack", stat = "identity") +
			scale_fill_manual(values=c("#CCCCCC","#178a94","#ee8080","#d03161")) +
	    geom_hline(yintercept = mags_bases_mean, linetype = "dashed", color = "black") +
	    labs(x = "Samples", y = "Amount of data (GB)") +
	    theme_classic() +
	    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size=6),legend.position = "bottom")

#' \newpage
#' ## 3.2 Estimated vs. mapped prokaryotic fraction
#' The main metric employed to assess the representativeness of a prokaryotic community using genome-resolved
#' metagenomics is to measure the percentage or reads mapped to the MAG catalogue. This metric, however can be
#' slippery when prokaryotic DNA is not dominant in the metagenomic mixture. Host DNA, dietary DNA, viral DNA and
#' other non-prokaryotic DNA sequences can drastically underestimate representativeness in such cases. In the EHI
#' we also employ another metric which estimated the proportion of prokaryotic sequences in a sample relying on
#' coverage values on marker genes and extrapolation of genome sizes of the closest relatives. Combining both approaches,
#' we can better estimate whether a prokaryotic community has been properly represented, or whether further sequencing
#' is required. In the below chart, a longer the orange line indicates that the mapping rate is further away from the
#' expected fraction of prokaryotic DNA. The absence of lines and brown dots indicate that the mapping rate and the
#' estimated fraction match, so the representativeness is correct. When the mapping value is at zero, it indicates that
#' not enough metagenomic data was generated for this type of analyses, usually due to excessive host DNA.

#+ singlem_calculations, echo=FALSE, warning=FALSE
singlem_table <- sequence_fractions %>%
	mutate(mags_proportion = round((mags_bases / (mags_bases + unmapped_bases))*100,2)) %>%
	left_join(sample_table, by = join_by(sample == sample))  %>%
	mutate(singlem_proportion = round(singlem_fraction*100,2)) %>%
	select(sample,mags_proportion,singlem_proportion) %>%
	mutate(mags_proportion = ifelse(singlem_proportion == 0, 0, mags_proportion)) %>% #convert zeros to NA
	mutate(singlem_proportion = ifelse(singlem_proportion == 0, NA, singlem_proportion)) %>% #convert zeros to NA
	mutate(singlem_proportion = ifelse(singlem_proportion < mags_proportion, NA, singlem_proportion)) %>% #if singlem is smaller, then NA, to simplify plot
	mutate(singlem_proportion = ifelse(singlem_proportion > 100, 100, singlem_proportion)) #simplify

#+ singlem_plot, echo=FALSE, warning=FALSE, fig.height=6
singlem_table %>%
	pivot_longer(!sample, names_to = "proportion", values_to = "value") %>%
	mutate(proportion = factor(proportion, levels = c("mags_proportion","singlem_proportion"))) %>%
	ggplot(., aes(x = value, y = sample, color=proportion)) +
			geom_line(aes(group = sample), color = "#f8a538") +
			geom_point() +
			scale_color_manual(values=c("#52e1e8","#876b53")) +
			theme_classic() +
			labs(y = "Samples", x = "Prokaryotic fraction (%)") +
	    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size=6),legend.position = "right")

#' \newpage
#' ## 3.3 Extra sequencing effort required
#' Estimating the amount of host and metagenomic data required for robust hologenomic analyses is very complex,
#' because these values are dependent on many system and study-specific factors. Here you will find the minimum
#' data requirements that work for most systems, which take as reference a desired amount of 5GB of host DNA
#' and 2GB of prokaryotic DNA. The calculations of extra sequencing required take into account the different
#' fractions of sequencing data, including low-quality, host, MAG catalogue-mapped and other metagenomic reads.
#' The bars exceding the vertical dashed bar set at 20GB of data indicate that more than 20GBs are
#' required to reach the desired amount of host or prokaryotic data. You can check the table for the actual
#' value, but bear in mind that generating more than 20GB of data is economically prohibitive in most cases.
#+ data_required, echo=FALSE, warning=FALSE
mags_bases_aim=2
host_bases_aim=5

sequence_fractions_required <- sequence_fractions %>%
	mutate(mags_bases = round(mags_bases / 1000000000,2)) %>%
	mutate(unmapped_bases = round(unmapped_bases / 1000000000,2)) %>%
	mutate(host_bases = round(host_bases / 1000000000,2)) %>%
	mutate(lowqual_bases = round(lowqual_bases / 1000000000,2)) %>%
	mutate(total_bases = mags_bases+unmapped_bases+host_bases+lowqual_bases) %>%
	mutate(mags_bases_fraction = mags_bases/total_bases) %>%
	mutate(mags_bases_difference = mags_bases_aim - mags_bases) %>%
	mutate(meta_required = round(mags_bases_difference / mags_bases_fraction,2)) %>%
	mutate(meta_required = ifelse(meta_required < 0, 0, meta_required)) %>%
	mutate(host_bases_fraction = host_bases/total_bases) %>%
	mutate(host_bases_difference = host_bases_aim - host_bases) %>%
	mutate(host_required = round(host_bases_difference / host_bases_fraction,2)) %>%
	mutate(host_required = ifelse(host_required < 0, 0, host_required)) %>%
	select(sample,mags_bases,unmapped_bases,host_bases,lowqual_bases,meta_required,host_required)

#+ data_required_barplot, echo=FALSE, warning=FALSE, fig.height=7
sequence_fractions_required %>%
	select(sample,meta_required,host_required) %>%
	mutate(meta_required = ifelse(meta_required > 20, 21, meta_required)) %>%
	mutate(host_required = ifelse(host_required > 20, 21, host_required)) %>%
	pivot_longer(!sample, names_to = "requirement", values_to = "value") %>%
	mutate(requirement = factor(requirement, levels = c("host_required","meta_required"))) %>%
	ggplot(., aes(x = value, y = sample, fill=requirement, group=requirement)) +
	    geom_bar(position="stack", stat = "identity") +
			scale_fill_manual(values=c("#178a94","#d03161")) +
			facet_wrap(~requirement, scales="free_x") +
			labs(x = "Amount of data (GB)", y = "Samples") +
			geom_vline(xintercept = 20, linetype = "dashed", color = "black") +
	    theme_classic() +
	    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size=6),legend.position = "bottom")


#+ data_required_table, echo=FALSE, warning=FALSE
sequence_fractions_required	%>%
	kable()

#+ print_data_required_table, echo=FALSE, warning=FALSE
write.table(sequence_fractions_required,"sequencing_stats.tsv",sep="\t",quote=FALSE,col.names=TRUE,row.names=FALSE)

#' \newpage
#' # 4. Count data
#' ## 4.1 Minimum genome-coverage filtering
#' Mapping of sequencing reads against the reference genome catalogue is not perfect,
#' and in consequence, all MAGs tend to get a few reads assigned. Implementing a
#' minimum genome coverage filter aims at minimising artificial inflation of diversity
#' due to this artifact of genome-resolved metagenomic analysis. The EHI pipeline implements a default coverage
#' threshold of 0.3 (%30) of a genome. However, if the sequencing depth is low and uneven across samples,
#' this filtering can also introduce distorsion, by introducing false positives.

#+ echo=FALSE, warning=FALSE
#Apply coverage filtering filtering
min_coverage=0.3
count_table_cov <- coverage_table %>%
  mutate(across(everything(), ~ ifelse(. > min_coverage, 1, 0))) %>%
  map2_df(., count_table, ~ .x * .y) %>%
  as.data.frame()
rownames(count_table_cov) <- rownames(coverage_table)

#' ## 4.2 Genome-size normalisation
#' Bacterial genomes can vary between 1 and 8 MB, which make relative representation of
#' each genome dependent on its size. To account for genome size biases, read-counts
#' can be normalised by applying a normalisation factor that modifies the read numbers
#' according to the size of each genome compared to the average genome size in the dataset.
#'

#+ echo=FALSE, warning=FALSE
#Transform to bacterial genome counts
#How many reads are needed to cover each genome
#143 nt is the average read-length after quality filtering in EHI data
genome_read_sizes <- mags_table[rownames(count_table_cov),] %>%
    select(mag_size) %>%
    mutate(mag_size = mag_size / 143) %>%
    pull()
count_table_cov_size <- sweep(count_table_cov, 1, genome_read_sizes, "/")

#' \newpage
#' ## 4.3 Count table
#' Once low-coverage genome counts have been filtered out, and the read counts have been normalised into genome
#' counts, we can visualise the relative MAG abundances per sample. Note that the count scale is log-transformed.
#+ cov_size_heatmap, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=6
vertical_tree <- force.ultrametric(tree,method="extend") %>%
		ggtree(., size = 0.3)

#Add phylum colors
vertical_tree <- gheatmap(vertical_tree, heatmap, offset=0, width=0.1, colnames=FALSE) +
	scale_fill_manual(values=colors_alphabetic)

#Reset fill scale
vertical_tree <- vertical_tree + new_scale_fill()

#Add counts
vertical_tree <- gheatmap(vertical_tree, log10(count_table_cov_size), offset=0.04, width=3.5, colnames=TRUE, colnames_angle=90, font.size=2, colnames_position="top", colnames_offset_y = 9) +
	vexpand(.08) +
	coord_cartesian(clip = "off") +
	scale_fill_gradient(low = "white", high = "steelblue", na.value="white")

#PLot tree
vertical_tree +
	theme(legend.position='none')

#Add count scale
#+ count_legends, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=1.5
countscale <- seq(log(max(count_table_cov_size, na.rm=T)), 0, length.out = 5)

count_legend <- data.frame(value = countscale, x = c(round(exp(countscale[1]),2),round(exp(countscale[2]),2),round(exp(countscale[3]),2),round(exp(countscale[4]),2),"0")) %>%
	mutate(x = factor(x, levels = x)) %>%
	ggplot(., aes(x = x, y = 0.2)) +
  geom_tile(aes(fill = value, y = 0.2), color="#CCCCCC") +
	scale_fill_gradient(low = "white", high = "steelblue", na.value="white") +
  theme_void() +
  theme(legend.position='none',
			axis.text.x = element_text(angle = 90, vjust = 1, hjust=1, size=8))

#Arrange both legends
grid.arrange(grobs = list(phyla_legend,count_legend), layout_matrix = rbind(c(1,1,2),c(1,1,3)))

#' \newpage
#' # 5. Taxonomic composition
#' Taxonomic composition of each sample shown after total sum scaling (TSS) normalisation.
#' Note that TSS normalisation simply divides each count value for the total count for the
#' sample, thus transforming the data to 0-1 scale. TSS or similar procedures that normalise
#' data to the 0-1 scale are required for some downstream analyses, such as Hill number computation.
#' However, it is important to bear in mind that TSS normalisation is agnostic to sequencing depth,
#' thus if depth is very uneven across samples, the results can be largely distorted. Each tile in the
#' figure corresponds to a MAG, while colors indicate their phylum-level taxonomic assignment.
#+ echo=FALSE, warning=FALSE
count_table_cov_size_pivot <- count_table_cov_size %>%
  rownames_to_column("Genome") %>%
  mutate_at(vars(-Genome),~./sum(.)) %>% #apply TSS nornalisation
  pivot_longer(-Genome, names_to = "sample", values_to = "count") %>% #reduce to minimum number of columns
  left_join(., mags_table, by = join_by(Genome == genome)) %>% #append taxonomy
  mutate(phylum = fct_relevel(phylum, rev(ehi_phylum_colors$phylum))) #sort phyla by taxonomy

#+ echo=FALSE, warning=FALSE
# Retrieve taxonomy colors to use standardised EHI colors
phylum_colors <- ehi_phylum_colors %>%
  filter(phylum %in% unique(count_table_cov_size_pivot$phylum)) %>%
  select(colors) %>%
  pull() %>%
  rev()
phylum_colors <- c(phylum_colors,"#cccccc") #REMOVE! ONLY FOR ARCHAEANS

#+ barplot, echo=FALSE, warning=FALSE, fig.height=5.5
# Plot stacked barplot
ggplot(count_table_cov_size_pivot, aes(x=sample,y=count,fill=phylum, group=phylum))+ #grouping enables keeping the same sorting of taxonomic units
    geom_bar(stat="identity", colour="white", linewidth=0.1)+ #plot stacked bars with white borders
    scale_fill_manual(values=phylum_colors) +
    labs(y = "Relative abundance") +
    guides(fill = guide_legend(ncol = 3)) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
					axis.title.x = element_blank(),
          panel.background = element_blank(),
          panel.border = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_line(linewidth = 0.5, linetype = "solid", colour = "black"),
          legend.position="none",
          legend.title=element_blank())

#+ barplot_legend, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=1.5
phyla_legend


#' \newpage
#' # 6. Diversity analyses

#' ## 6.1 Alpha diversity
#' Diversity estimatimations for each sample.\
#' **Richness:** Number of MAGs per sample (after applying coverage filter).\
#' **Neutral diversity:** Hill number of q=1 (Shannon diversity), a diversity metric that
#' accounts for richness and eveness (relative abundances) of the MAGs.\
#' **Phylogenetic (phylo) diversity:** Phylogenetic Hill number of q=1, a diversity metric that
#' accounts for richness and eveness (relative abundances), as well as phylogenetic
#' relationships among MAGs.\
#' **Functional (func) diversity:** Functional Hill number of q=1, a diversity metric that
#' accounts for richness and eveness (relative abundances), as well as functional
#' dissimilarities among MAGs.\

#+ alpha_divs, echo=FALSE, warning=FALSE, comments="", message=FALSE

#Get list of present MAGs
present_MAGs <- count_table_cov_size %>%
		filter(rowSums(.[, -1]) != 0) %>%
		rownames()

#Remove samples with all zeros (no data after filtering)
count_table_cov_size <- count_table_cov_size %>%
  select_if(~!all(. == 0))

#Align KEGG annotations with present MAGs and remove all-zero and all-one traits
if(func == "yes"){
	present_MAGs <- present_MAGs[present_MAGs %in% rownames(kegg_table)]
	kegg_table_filt <- kegg_table[present_MAGs,] %>%
			select_if(~!all(. == 0)) %>%  #remove all-zero modules
			select_if(~!all(. == 1)) #remove all-one modules
}

#Compute alpha Hill numbers
q0n <- hilldiv(count_table_cov_size,q=0) %>% c()
q1n <- hilldiv(count_table_cov_size,q=1) %>% c()
q1p <- hilldiv(count_table_cov_size,q=1,tree=tree) %>% c()

#If functional data is present
if(func == "yes"){
	dist <- traits2dist(kegg_table_filt, method="gower")
	#Filter count table to only contain present MAGs after KEGG filtering
	count_table_cov_size_filt <- count_table_cov_size[present_MAGs,]
	#print(cbind(rownames(count_table_cov_size),rownames(dist),colnames(dist)))
	q1f <- hilldiv(count_table_cov_size_filt,q=1,dist=dist) %>% c()
}

#+ alpha_divs_merge, echo=FALSE, warning=FALSE, comments="", message=FALSE
# Merge all alpha diversities

if(func == "yes"){
	#With functional data
	alpha_div <- cbind(sample=colnames(count_table_cov_size),richness=q0n,neutral=round(q1n,3),phylo=round(q1p,3),func=round(q1f,3)) %>%
		as.data.frame()
	columns <- c("richness","neutral","phylo","func","mapped","total")

	alpha_div <- alpha_div %>%
		left_join(sequence_fractions, by = join_by(sample == sample)) %>% #add sequencing depth information
	  mutate(mapped=round(mags_bases/1000000000,3)) %>% #modify depth to million reads
		mutate(total=round((mags_bases+unmapped_bases+host_bases+lowqual_bases)/1000000000,3)) %>%
		select(sample,richness,neutral,phylo,func,mapped,total) %>%
		mutate(across(-1, as.numeric))

}else{
	#Without functional data
	alpha_div <- cbind(sample=colnames(count_table_cov_size),richness=q0n,neutral=round(q1n,3),phylo=round(q1p,3)) %>%
		as.data.frame()
	columns <- c("richness","neutral","phylo","mapped","total")

	alpha_div <- alpha_div %>%
		left_join(sequence_fractions, by = join_by(sample == sample)) %>% #add sequencing depth information
	  mutate(mapped=round(mags_bases/1000000000,3)) %>% #modify depth to million reads
		mutate(total=round((mags_bases+unmapped_bases+host_bases+lowqual_bases)/1000000000,3)) %>%
		select(sample,richness,neutral,phylo,mapped,total) %>%
		mutate(across(-1, as.numeric))
}

#+ alpha_divs_plot, echo=FALSE, warning=FALSE, fig.height=6
alpha_div %>%
		pivot_longer(-sample, names_to = "data", values_to = "value") %>%
		mutate(data = factor(data, levels = columns))	%>%
		ggplot(aes(x=value, y=sample)) +
			geom_bar(stat='identity', fill="#6c9ebc") +
			facet_wrap(~data,  scales="free_x", ncol=6) +
			theme_classic() +
			theme(
				strip.background = element_blank(),
				panel.grid.minor.x = element_line( size=.1, color="grey" ),
				axis.title.x = element_blank(),
				axis.title.y = element_blank(),
				axis.text.x = element_text(angle = 45, hjust = 1)
			)

#+ alpha_divs_table, echo=FALSE, warning=FALSE
kable(alpha_div, caption="Mapped and Total amount of data are shown in GB (gigabases)")

#' \newpage
#+ alpha_colors, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide"
alpha_colors <- c("#e5bd5b","#6b7398","#76b183","#d57d2c","#2a2d26","#f9d4cc","#3c634e","#ea68c3")


#+ alpha_divs_comp_plot1, echo=FALSE, warning=FALSE
group_n <- alpha_div %>% select(sample,neutral) %>%
		left_join(sample_table, by = join_by(sample == sample)) %>%
		select(species) %>% pull() %>% unique() %>% length()

#' `r if(group_n>1 && group_n<=8){paste0("\nAlpha diversity variation accross species.\n")}`

#+ alpha_divs_comp_plot1_neutral, echo=FALSE, warning=FALSE
if(group_n>1 && group_n<=8){
	alpha_div %>%
			select(sample,neutral) %>%
			pivot_longer(-sample, names_to = "data", values_to = "value") %>%
			mutate(data = factor(data, levels = columns))	%>%
			left_join(sample_table, by = join_by(sample == sample)) %>%
			mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
			ggboxplot(., x = "species", y = "value", color = "species", fill="species") +
					scale_color_manual(values=alpha_colors[c(1:group_n)]) +
					scale_fill_manual(values=paste0(alpha_colors[c(1:group_n)],"50")) +
					stat_compare_means() +
					theme_classic() +
					labs(y = "Neutral Hill numbers") +
					theme(
						legend.position = "top",
						legend.box = "horizontal",
						axis.title.x = element_blank(),
						axis.text.x = element_blank()) +
					guides(color=guide_legend(title="Species"), fill="none")
}

#+ alpha_divs_comp_plot1_phylo, echo=FALSE, warning=FALSE, fig.height=2.5
if(group_n>1 && group_n<=8){
	alpha_div %>%
			select(sample,phylo) %>%
			pivot_longer(-sample, names_to = "data", values_to = "value") %>%
			mutate(data = factor(data, levels = columns))	%>%
			left_join(sample_table, by = join_by(sample == sample)) %>%
			mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
			ggboxplot(., x = "species", y = "value", color = "species", fill="species") +
			scale_color_manual(values=alpha_colors[c(1:group_n)]) +
			scale_fill_manual(values=paste0(alpha_colors[c(1:group_n)],"50")) +
			stat_compare_means() +
			theme_classic() +
			labs(y = "Phylogenetic Hill numbers") +
			theme(
				legend.position = "none",
				axis.title.x = element_blank(),
				axis.text.x = element_blank())
}
#+ alpha_divs_comp_plot1_func, echo=FALSE, warning=FALSE, fig.height=2.5
if(group_n>1 && group_n<=8 && func == "yes"){
	alpha_div %>%
			select(sample,func) %>%
			pivot_longer(-sample, names_to = "data", values_to = "value") %>%
			mutate(data = factor(data, levels = columns))	%>%
			left_join(sample_table, by = join_by(sample == sample)) %>%
			mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
			ggboxplot(., x = "species", y = "value", color = "species", fill="species") +
			scale_color_manual(values=alpha_colors[c(1:group_n)]) +
			scale_fill_manual(values=paste0(alpha_colors[c(1:group_n)],"50")) +
			stat_compare_means() +
			theme_classic() +
			labs(y = "Functional Hill numbers") +
			theme(
				legend.position = "none",
				axis.title.x = element_blank(),
				axis.text.x = element_blank())
}

#' \newpage
#+ alpha_divs_comp_plot2, echo=FALSE, warning=FALSE
group_n <- alpha_div %>% select(sample,neutral) %>%
		left_join(sample_table, by = join_by(sample == sample)) %>%
		mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
		select(location) %>% pull() %>% unique() %>% length()

#' `r if(group_n>1 && group_n<=8){paste0("\nAlpha diversity variation accross locations.\n")}`

#+ alpha_divs_comp_plot2_neutral, echo=FALSE, warning=FALSE, fig.height=3.2

if(group_n>1 && group_n<=8){
	alpha_div %>%
			select(sample,neutral) %>%
			pivot_longer(-sample, names_to = "data", values_to = "value") %>%
			mutate(data = factor(data, levels = columns))	%>%
			left_join(sample_table, by = join_by(sample == sample)) %>%
			mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
			ggboxplot(., x = "location", y = "value", color = "location", fill="location") +
					scale_color_manual(values=alpha_colors[c(1:group_n)]) +
					scale_fill_manual(values=paste0(alpha_colors[c(1:group_n)],"50")) +
					stat_compare_means() +
					theme_classic() +
					labs(y = "Neutral Hill numbers") +
					theme(
						legend.position = "top",
						legend.box = "horizontal",
						axis.title.x = element_blank(),
						axis.text.x = element_blank()) +
					guides(color=guide_legend(title="Location"), fill="none")
}
#+ alpha_divs_comp_plot2_phylo, echo=FALSE, warning=FALSE, fig.height=2.5
if(group_n>1 && group_n<=8){
	alpha_div %>%
			select(sample,phylo) %>%
			pivot_longer(-sample, names_to = "data", values_to = "value") %>%
			mutate(data = factor(data, levels = columns))	%>%
			left_join(sample_table, by = join_by(sample == sample)) %>%
			mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
			ggboxplot(., x = "location", y = "value", color = "location", fill="location") +
			scale_color_manual(values=alpha_colors[c(1:group_n)]) +
			scale_fill_manual(values=paste0(alpha_colors[c(1:group_n)],"50")) +
			stat_compare_means() +
			theme_classic() +
			labs(y = "Phylogenetic Hill numbers") +
			theme(
				legend.position = "none",
				axis.title.x = element_blank(),
				axis.text.x = element_blank())
}
#+ alpha_divs_comp_plot2_func, echo=FALSE, warning=FALSE, fig.height=2.5
if(group_n>1 && group_n<=8 && func == "yes"){
	alpha_div %>%
			select(sample,func) %>%
			pivot_longer(-sample, names_to = "data", values_to = "value") %>%
			mutate(data = factor(data, levels = columns))	%>%
			left_join(sample_table, by = join_by(sample == sample)) %>%
			mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
			ggboxplot(., x = "location", y = "value", color = "location", fill="location") +
			scale_color_manual(values=alpha_colors[c(1:group_n)]) +
			scale_fill_manual(values=paste0(alpha_colors[c(1:group_n)],"50")) +
			stat_compare_means() +
			theme_classic() +
			labs(y = "Functional Hill numbers") +
			theme(
				legend.position = "none",
				axis.title.x = element_blank(),
				axis.text.x = element_blank())
}

#' \newpage
#+ alpha_divs_comp_plot3, echo=FALSE, warning=FALSE
group_n <- alpha_div %>% select(sample,neutral) %>%
		left_join(sample_table, by = join_by(sample == sample)) %>%
		select(region) %>% pull() %>% unique() %>% length()

#' `r if(group_n>1 && group_n<=8){paste0("\nAlpha diversity variation accross regions.\n")}`

#+ alpha_divs_comp_plot3_neutral, echo=FALSE, warning=FALSE, fig.height=3.2
if(group_n>1 && group_n<=8){
	alpha_div %>%
			select(sample,neutral) %>%
			pivot_longer(-sample, names_to = "data", values_to = "value") %>%
			mutate(data = factor(data, levels = columns))	%>%
			left_join(sample_table, by = join_by(sample == sample)) %>%
			mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
			ggboxplot(., x = "region", y = "value", color = "region", fill="region") +
					scale_color_manual(values=alpha_colors[c(1:group_n)]) +
					scale_fill_manual(values=paste0(alpha_colors[c(1:group_n)],"50")) +
					stat_compare_means() +
					theme_classic() +
					labs(y = "Neutral Hill numbers") +
					theme(
						legend.position = "top",
						legend.box = "horizontal",
						axis.title.x = element_blank(),
						axis.text.x = element_blank()) +
					guides(color=guide_legend(title="Region"), fill="none")
}
#+ alpha_divs_comp_plot3_phylo, echo=FALSE, warning=FALSE, fig.height=2.5
if(group_n>1 && group_n<=8){
	alpha_div %>%
			select(sample,phylo) %>%
			pivot_longer(-sample, names_to = "data", values_to = "value") %>%
			mutate(data = factor(data, levels = columns))	%>%
			left_join(sample_table, by = join_by(sample == sample)) %>%
			mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
			ggboxplot(., x = "region", y = "value", color = "region", fill="region") +
			scale_color_manual(values=alpha_colors[c(1:group_n)]) +
			scale_fill_manual(values=paste0(alpha_colors[c(1:group_n)],"50")) +
			stat_compare_means() +
			theme_classic() +
			labs(y = "Phylogenetic Hill numbers") +
			theme(
				legend.position = "none",
				axis.title.x = element_blank(),
				axis.text.x = element_blank())
}
#+ alpha_divs_comp_plot3_func, echo=FALSE, warning=FALSE, fig.height=2.5
if(group_n>1 && group_n<=8 && func == "yes"){
	alpha_div %>%
			select(sample,func) %>%
			pivot_longer(-sample, names_to = "data", values_to = "value") %>%
			mutate(data = factor(data, levels = columns))	%>%
			left_join(sample_table, by = join_by(sample == sample)) %>%
			mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
			ggboxplot(., x = "region", y = "value", color = "region", fill="region") +
			scale_color_manual(values=alpha_colors[c(1:group_n)]) +
			scale_fill_manual(values=paste0(alpha_colors[c(1:group_n)],"50")) +
			stat_compare_means() +
			theme_classic() +
			labs(y = "Functional Hill numbers") +
			theme(
				legend.position = "none",
				axis.title.x = element_blank(),
				axis.text.x = element_blank())
}

#' \newpage
#+ alpha_divs_comp_plot4, echo=FALSE, warning=FALSE
group_n <- alpha_div %>% select(sample,neutral) %>%
		left_join(sample_table, by = join_by(sample == sample)) %>%
		select(country) %>% pull() %>% unique() %>% length()

#' `r if(group_n>1 && group_n<=8){paste0("\nAlpha diversity variation accross countries.\n")}`

#+ alpha_divs_comp_plot4_neutral, echo=FALSE, warning=FALSE, fig.height=3.2
if(group_n>1 && group_n<=8){
	alpha_div %>%
			select(sample,neutral) %>%
			pivot_longer(-sample, names_to = "data", values_to = "value") %>%
			mutate(data = factor(data, levels = columns))	%>%
			left_join(sample_table, by = join_by(sample == sample)) %>%
			mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
			ggboxplot(., x = "country", y = "value", color = "country", fill="country") +
					scale_color_manual(values=alpha_colors[c(1:group_n)]) +
					scale_fill_manual(values=paste0(alpha_colors[c(1:group_n)],"50")) +
					stat_compare_means() +
					theme_classic() +
					labs(y = "Neutral Hill numbers") +
					theme(
						legend.position = "top",
						legend.box = "horizontal",
						axis.title.x = element_blank(),
						axis.text.x = element_blank()) +
					guides(color=guide_legend(title="Country"), fill="none")
}
#+ alpha_divs_comp_plot4_phylo, echo=FALSE, warning=FALSE, fig.height=2.5
if(group_n>1 && group_n<=8){
	alpha_div %>%
			select(sample,phylo) %>%
			pivot_longer(-sample, names_to = "data", values_to = "value") %>%
			mutate(data = factor(data, levels = columns))	%>%
			left_join(sample_table, by = join_by(sample == sample)) %>%
			mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
			ggboxplot(., x = "country", y = "value", color = "country", fill="country") +
			scale_color_manual(values=alpha_colors[c(1:group_n)]) +
			scale_fill_manual(values=paste0(alpha_colors[c(1:group_n)],"50")) +
			stat_compare_means() +
			theme_classic() +
			labs(y = "Phylogenetic Hill numbers") +
			theme(
				legend.position = "none",
				axis.title.x = element_blank(),
				axis.text.x = element_blank())
}
#+ alpha_divs_comp_plot4_func, echo=FALSE, warning=FALSE, fig.height=2.5
if(group_n>1 && group_n<=8 && func == "yes"){
	alpha_div %>%
			select(sample,func) %>%
			pivot_longer(-sample, names_to = "data", values_to = "value") %>%
			mutate(data = factor(data, levels = columns))	%>%
			left_join(sample_table, by = join_by(sample == sample)) %>%
			mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
			ggboxplot(., x = "country", y = "value", color = "country", fill="country") +
			scale_color_manual(values=alpha_colors[c(1:group_n)]) +
			scale_fill_manual(values=paste0(alpha_colors[c(1:group_n)],"50")) +
			stat_compare_means() +
			theme_classic() +
			labs(y = "Functional Hill numbers") +
			theme(
				legend.position = "none",
				axis.title.x = element_blank(),
				axis.text.x = element_blank())
}

#' \newpage
#+ alpha_divs_comp_plot5, echo=FALSE, warning=FALSE
group_n <- alpha_div %>% select(sample,neutral) %>%
		left_join(sample_table, by = join_by(sample == sample)) %>%
		select(sex) %>% pull() %>% unique() %>% length()

#' `r if(group_n>1 && group_n<=8){paste0("\nAlpha diversity variation between sexes.\n")}`

#+ alpha_divs_comp_plot5_neutral, echo=FALSE, warning=FALSE, fig.height=3.2
if(group_n>1 && group_n<=8){
	alpha_div %>%
			select(sample,neutral) %>%
			pivot_longer(-sample, names_to = "data", values_to = "value") %>%
			mutate(data = factor(data, levels = columns))	%>%
			left_join(sample_table, by = join_by(sample == sample)) %>%
			mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
			ggboxplot(., x = "sex", y = "value", color = "sex", fill="sex") +
			scale_color_manual(values=alpha_colors[c(1:group_n)]) +
			scale_fill_manual(values=paste0(alpha_colors[c(1:group_n)],"50")) +
			stat_compare_means() +
			theme_classic() +
			labs(y = "Neutral Hill numbers") +
			theme(
				legend.position="top", legend.box="horizontal",
				axis.title.x = element_blank(),
				axis.text.x = element_blank()) +
			guides(color=guide_legend(title="Sex"), fill="none")
}

#+ alpha_divs_comp_plot5_phylo, echo=FALSE, warning=FALSE, fig.height=2.5
if(group_n>1 && group_n<=8){
	alpha_div %>%
			select(sample,phylo) %>%
			pivot_longer(-sample, names_to = "data", values_to = "value") %>%
			mutate(data = factor(data, levels = columns))	%>%
			left_join(sample_table, by = join_by(sample == sample)) %>%
			mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
			ggboxplot(., x = "sex", y = "value", color = "sex", fill="sex") +
			scale_color_manual(values=alpha_colors[c(1:group_n)]) +
			scale_fill_manual(values=paste0(alpha_colors[c(1:group_n)],"50")) +
			stat_compare_means() +
			theme_classic() +
			labs(y = "Phylogenetic Hill numbers") +
			theme(
				legend.position = "none",
				axis.title.x = element_blank(),
				axis.text.x = element_blank()) +
			guides(color=guide_legend(title="Sex"), fill="none")
}
#+ alpha_divs_comp_plot5_func, echo=FALSE, warning=FALSE, fig.height=2.5
if(group_n>1 && group_n<=8 && func == "yes"){
	alpha_div %>%
			select(sample,func) %>%
			pivot_longer(-sample, names_to = "data", values_to = "value") %>%
			mutate(data = factor(data, levels = columns))	%>%
			left_join(sample_table, by = join_by(sample == sample)) %>%
			mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
			ggboxplot(., x = "sex", y = "value", color = "sex", fill="sex") +
			scale_color_manual(values=alpha_colors[c(1:group_n)]) +
			scale_fill_manual(values=paste0(alpha_colors[c(1:group_n)],"50")) +
			stat_compare_means() +
			theme_classic() +
			labs(y = "Functional Hill numbers") +
			theme(
				legend.position = "none",
				axis.title.x = element_blank(),
				axis.text.x = element_blank()) +
			guides(color=guide_legend(title="Sex"), fill="none")
}

#' \newpage
#+ alpha_divs_comp_plot6, echo=FALSE, warning=FALSE
group_n <- alpha_div %>% select(sample,neutral) %>%
		left_join(sample_table, by = join_by(sample == sample)) %>%
		select(sample_type) %>% pull() %>% unique() %>% length()

#' `r if(group_n>1 && group_n<=8){paste0("\nAlpha diversity variation across sample types.\n")}`

#+ alpha_divs_comp_plot6_neutral, echo=FALSE, warning=FALSE, fig.height=3.2
if(group_n>1 && group_n<=8){
	alpha_div %>%
			select(sample,neutral) %>%
			pivot_longer(-sample, names_to = "data", values_to = "value") %>%
			mutate(data = factor(data, levels = columns))	%>%
			left_join(sample_table, by = join_by(sample == sample)) %>%
			mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
			ggboxplot(., x = "sample_type", y = "value", color = "sample_type", fill="sample_type") +
			scale_color_manual(values=alpha_colors[c(1:group_n)]) +
			scale_fill_manual(values=paste0(alpha_colors[c(1:group_n)],"50")) +
			stat_compare_means() +
			theme_classic() +
			labs(y = "Neutral Hill numbers") +
			theme(
				legend.position="top", legend.box="horizontal",
				axis.title.x = element_blank(),
				axis.text.x = element_blank()) +
			guides(color=guide_legend(title="Sample type"), fill="none")
}
#+ alpha_divs_comp_plot6_phylo, echo=FALSE, warning=FALSE, fig.height=2.5
if(group_n>1 && group_n<=8){
	alpha_div %>%
			select(sample,phylo) %>%
			pivot_longer(-sample, names_to = "data", values_to = "value") %>%
			mutate(data = factor(data, levels = columns))	%>%
			left_join(sample_table, by = join_by(sample == sample)) %>%
			mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
			ggboxplot(., x = "sample_type", y = "value", color = "sample_type", fill="sample_type") +
			scale_color_manual(values=alpha_colors[c(1:group_n)]) +
			scale_fill_manual(values=paste0(alpha_colors[c(1:group_n)],"50")) +
			stat_compare_means() +
			theme_classic() +
			labs(y = "Phylogenetic Hill numbers") +
			theme(
				legend.position = "none",
				axis.title.x = element_blank(),
				axis.text.x = element_blank()) +
			guides(color=guide_legend(title="Sex"), fill="none")
}
#+ alpha_divs_comp_plot6_func, echo=FALSE, warning=FALSE, fig.height=2.5
if(group_n>1 && group_n<=8 && func == "yes"){
	alpha_div %>%
			select(sample,func) %>%
			pivot_longer(-sample, names_to = "data", values_to = "value") %>%
			mutate(data = factor(data, levels = columns))	%>%
			left_join(sample_table, by = join_by(sample == sample)) %>%
			mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
			ggboxplot(., x = "sample_type", y = "value", color = "sample_type", fill="sample_type") +
			scale_color_manual(values=alpha_colors[c(1:group_n)]) +
			scale_fill_manual(values=paste0(alpha_colors[c(1:group_n)],"50")) +
			stat_compare_means() +
			theme_classic() +
			labs(y = "Functional Hill numbers") +
			theme(
				legend.position = "none",
				axis.title.x = element_blank(),
				axis.text.x = element_blank()) +
			guides(color=guide_legend(title="Sex"), fill="none")
}

#' \newpage
#' ## 6.2 Relationship between sequencing and alpha diversities
#' The microbial diversity in a sample is often correlated with sequencing depth, mainly when the sequencing effort is not large
#' enough to properly capture the entirety of the diversity in the sample. The following plot shows the relationship between
#' neutral diversity (Hill number of q=1, Shannon diversity) and the GBs mapped to the MAG catalogue. The size of the dots indicates
#' the total sequencing effort performed for that sample (including host DNA, non-mapped reads, etc.). The flatter the regression line
#' the lower is the correlation, and thus lower is the effect of sequencing depth in the results. However, it must be noted that this
#' analysis only compares the sequencing depth in relation to the MAG catalogue, which might not be complete or representative of the
#' system. Hence, the results shown here must be interpreted cautiously.

#+ alpha_depth_neutral, echo=FALSE, warning=FALSE, fig.height=5
ggplot(alpha_div, aes(x=mapped,y=neutral,size=total,label=sample)) +
  		geom_smooth(method='lm', formula= y~x, color='#e08dde', fill='#e08dde') +
      geom_point(alpha=0.5, color="#6c9ebc") +
      geom_label_repel(max.overlaps = 100, cex=0.7) +
      labs(x = "GBs mapped to MAGs", y = "Neutral diversity (effective number of MAGs)") +
      theme_classic() +
			theme(legend.position="none")


#' \newpage
#' ## 6.3 Beta diversity
#' Pairwise beta diversities quantify the dissimilarity between samples. Within the Hill numbers framework, beta diversities can be calculated for
#' neutral, phylogenetic and functional diversities, at the desired order of diversity (q-value). Often times, beta diversities differ depending on
#' the components of the diversity. For instance, phylogenetic and functional diversities often display lower beta values than neutral diversities due to
#' phylogenetic and functional redundancy of the microbiota (i.e. different yet closely related and functionally similar MAGs replace each other).
#' Pairwise beta diversities can be displayed in a 2-dimensional ordination using NMDS, and can be used to test for compositional differences between variables of interest.
#' In the following pages, PERMANOVAs are conducted against all metadata variables with >1 different values, and NMDS ordinations are
#' displayed for all metadata features containing between 2 and 8 different values. Note that outliers (often technical failures) can
#' distort the ordination considerably.
#'

#+ beta_colors, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide"
beta_colors <- c("#e5bd5b","#6b7398","#76b183","#d57d2c","#2a2d26","#f9d4cc","#3c634e","#ea68c3")

#' ### 6.3.1 Neutral beta diversity
#' The PERMANOVA analysis based on neutral beta diversities indicates whether microbiomes vary between metadata variables.

#+ beta_neutral, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide"
beta_q1n <- hillpair(count_table_cov_size,q=1) %>%
				select(first,second,C) %>% #based on dissimilarity metric C
				as.data.frame() %>%
				pivot_wider(names_from = first, values_from = C) %>%
				column_to_rownames(var = "second") %>%
				as.matrix() %>%
				as.dist()

#+ beta_neutral_permanova_input, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide"
sample_table_adonis <- sample_table %>%
	filter(sample %in% labels(beta_q1n)) %>%
	arrange(sample) %>%
	mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
	select(sample,location,region,country,species,sex,sample_type) %>%
	select_if(~ length(unique(.)) > 1) %>% #remove columns with all-identical values
	column_to_rownames(var = "sample") %>%
	as.data.frame()

#+ beta_neutral_permanova, echo=FALSE, warning=FALSE, comments="", message=FALSE
if(ncol(sample_table_adonis)>1){
	adonis2(formula=beta_q1n ~ ., data=sample_table_adonis[labels(beta_q1n),], permutations=999) %>%
			as.matrix() %>%
			kable()
}else if(ncol(sample_table_adonis)==1){ # fix in case of a single variable
	adonis_matrix<-adonis2(formula=beta_q1n ~ sample_table_adonis[labels(beta_q1n),], permutations=999) %>%
			as.matrix()
	rownames(adonis_matrix)[1] <- colnames(sample_table_adonis)
	adonis_matrix %>%
			kable()
}else{
	print("PERMANOVA was not conducted because of lack of metadata variability")
}

#+ beta_neutral_nmds, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide"
beta_q1n_nmds <- beta_q1n %>%
				metaMDS(.,trymax = 500, k=2, verbosity=FALSE) %>%
				scores() %>%
				as_tibble(., rownames = "sample") %>%
				left_join(sample_table, by = join_by(sample == sample)) %>%
				mutate(location=paste0(round(longitude,2),"_",round(latitude,2)))

#+ beta_neutral_plot1, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=4
if(length(unique(beta_q1n_nmds$species))>1 && length(unique(beta_q1n_nmds$species))<=8){
group_n <- length(unique(beta_q1n_nmds$species))
beta_q1n_nmds %>%
			group_by(species) %>%
			mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
			mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
			ungroup() %>%
			ggplot(., aes(x=NMDS1,y=NMDS2, color=species)) +
				scale_color_manual(values=beta_colors[c(1:group_n)]) +
				geom_point(size=2) +
				geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
				theme_classic() +
				theme(legend.position="right", legend.box="vertical") +
				guides(color=guide_legend(title="Species"))
}

#+ beta_neutral_plot2, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=4
if(length(unique(beta_q1n_nmds$location))>1 && length(unique(beta_q1n_nmds$location))<=8){
group_n <- length(unique(beta_q1n_nmds$location))
beta_q1n_nmds %>%
			group_by(location) %>%
			mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
			mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
			ungroup() %>%
			ggplot(., aes(x=NMDS1,y=NMDS2, color=location)) +
				scale_color_manual(values=beta_colors[c(1:group_n)]) +
				geom_point(size=2) +
				geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
				theme_classic() +
				theme(legend.position="right", legend.box="vertical") +
				guides(color=guide_legend(title="Location"))
}

#+ beta_neutral_plot3, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=4
if(length(unique(beta_q1n_nmds$region))>1 && length(unique(beta_q1n_nmds$region))<=8){
group_n <- length(unique(beta_q1n_nmds$region))
beta_q1n_nmds %>%
			group_by(region) %>%
			mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
			mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
			ungroup() %>%
			ggplot(., aes(x=NMDS1,y=NMDS2, color=region)) +
				scale_color_manual(values=beta_colors[c(1:group_n)]) +
				geom_point(size=2) +
				geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
				theme_classic() +
				theme(legend.position="right", legend.box="vertical") +
				guides(color=guide_legend(title="Region"))
}

#+ beta_neutral_plot4, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=4
if(length(unique(beta_q1n_nmds$country))>1 && length(unique(beta_q1n_nmds$country))<=8){
group_n <- length(unique(beta_q1n_nmds$country))
beta_q1n_nmds %>%
			group_by(country) %>%
			mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
			mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
			ungroup() %>%
			ggplot(., aes(x=NMDS1,y=NMDS2, color=country)) +
				scale_color_manual(values=beta_colors[c(1:group_n)]) +
				geom_point(size=2) +
				geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
				theme_classic() +
				theme(legend.position="right", legend.box="vertical") +
				guides(color=guide_legend(title="Country"))
}

#+ beta_neutral_plot5, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=4
if(length(unique(beta_q1n_nmds$sex))>1 && length(unique(beta_q1n_nmds$sex))<=8){
group_n <- length(unique(beta_q1n_nmds$sex))
beta_q1n_nmds %>%
			group_by(sex) %>%
			mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
			mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
			ungroup() %>%
			ggplot(., aes(x=NMDS1,y=NMDS2, color=sex)) +
				scale_color_manual(values=beta_colors[c(1:group_n)]) +
				geom_point(size=2) +
				geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
				theme_classic() +
				theme(legend.position="right", legend.box="vertical") +
				guides(color=guide_legend(title="Sex"))
}

#+ beta_neutral_plot6, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=4
if(length(unique(beta_q1n_nmds$sample_type))>1 && length(unique(beta_q1n_nmds$sample_type))<=8){
group_n <- length(unique(beta_q1n_nmds$sample_type))
beta_q1n_nmds %>%
			group_by(sample_type) %>%
			mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
			mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
			ungroup() %>%
			ggplot(., aes(x=NMDS1,y=NMDS2, color=sample_type)) +
				scale_color_manual(values=beta_colors[c(1:group_n)]) +
				geom_point(size=2) +
				geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
				theme_classic() +
				theme(legend.position="right", legend.box="vertical") +
				guides(color=guide_legend(title="Sample type"))
}

#' \newpage
#' ### 6.3.2 Phylogenetic beta diversity
#' The PERMANOVA analysis based on phylogenetic beta diversities indicates whether phylogenetic attributes of microbiomes
#' vary between metadata variables.

#+ beta_phylo, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide"
beta_q1p <- hillpair(count_table_cov_size,q=1,tree=tree) %>%
				select(first,second,C) %>% #based on dissimilarity metric C
				as.data.frame() %>%
				pivot_wider(names_from = first, values_from = C) %>%
				column_to_rownames(var = "second") %>%
				as.matrix() %>%
				as.dist()

#+ beta_phylo_permanova_input, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide"
sample_table_adonis <- sample_table %>%
	filter(sample %in% labels(beta_q1p)) %>%
	arrange(sample) %>%
	mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
	select(sample,location,region,country,species,sex,sample_type) %>%
	select_if(~ length(unique(.)) > 1) %>% #remove columns with all-identical values
	column_to_rownames(var = "sample") %>%
	as.data.frame()

#+ beta_phylo_permanova, echo=FALSE, warning=FALSE, comments="", message=FALSE
if(ncol(sample_table_adonis)>1){
	adonis2(formula=beta_q1p ~ ., data=sample_table_adonis[labels(beta_q1p),], permutations=999) %>%
			as.matrix() %>%
			kable()
}else if(ncol(sample_table_adonis)==1){ # fix in case of a single variable
	adonis_matrix<-adonis2(formula=beta_q1p ~ sample_table_adonis[labels(beta_q1p),], permutations=999) %>%
			as.matrix()
	rownames(adonis_matrix)[1] <- colnames(sample_table_adonis)
	adonis_matrix %>%
			kable()
}else{
	print("PERMANOVA was not conducted because of lack of metadata variability")
}

#+ beta_phylo_nmds, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide"
beta_q1p_nmds <- beta_q1p %>%
				metaMDS(.,trymax = 500, k=2, verbosity=FALSE) %>%
				scores() %>%
				as_tibble(., rownames = "sample") %>%
				left_join(sample_table, by = join_by(sample == sample)) %>%
				mutate(location=paste0(round(longitude,2),"_",round(latitude,2)))

#+ beta_phylo_plot1, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=4
if(length(unique(beta_q1p_nmds$species))>1 && length(unique(beta_q1p_nmds$species))<=8){
group_n <- length(unique(beta_q1p_nmds$species))
beta_q1p_nmds %>%
			group_by(species) %>%
			mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
			mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
			ungroup() %>%
			ggplot(., aes(x=NMDS1,y=NMDS2, color=species)) +
				scale_color_manual(values=beta_colors[c(1:group_n)]) +
				geom_point(size=2) +
				geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
				theme_classic() +
				theme(legend.position="right", legend.box="vertical") +
				guides(color=guide_legend(title="Species"))
}

#+ beta_phylo_plot2, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=4
if(length(unique(beta_q1p_nmds$location))>1 && length(unique(beta_q1p_nmds$location))<=8){
group_n <- length(unique(beta_q1p_nmds$location))
beta_q1p_nmds %>%
			group_by(location) %>%
			mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
			mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
			ungroup() %>%
			ggplot(., aes(x=NMDS1,y=NMDS2, color=location)) +
				scale_color_manual(values=beta_colors[c(1:group_n)]) +
				geom_point(size=2) +
				geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
				theme_classic() +
				theme(legend.position="right", legend.box="vertical") +
				guides(color=guide_legend(title="Location"))
}

#+ beta_phylo_plot3, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=4
if(length(unique(beta_q1p_nmds$region))>1 && length(unique(beta_q1p_nmds$region))<=8){
group_n <- length(unique(beta_q1p_nmds$region))
beta_q1p_nmds %>%
			group_by(region) %>%
			mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
			mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
			ungroup() %>%
			ggplot(., aes(x=NMDS1,y=NMDS2, color=region)) +
				scale_color_manual(values=beta_colors[c(1:group_n)]) +
				geom_point(size=2) +
				geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
				theme_classic() +
				theme(legend.position="right", legend.box="vertical") +
				guides(color=guide_legend(title="Region"))
}

#+ beta_phylo_plot4, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=4
if(length(unique(beta_q1p_nmds$country))>1 && length(unique(beta_q1p_nmds$country))<=8){
group_n <- length(unique(beta_q1p_nmds$country))
beta_q1p_nmds %>%
			group_by(country) %>%
			mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
			mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
			ungroup() %>%
			ggplot(., aes(x=NMDS1,y=NMDS2, color=country)) +
				scale_color_manual(values=beta_colors[c(1:group_n)]) +
				geom_point(size=2) +
				geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
				theme_classic() +
				theme(legend.position="right", legend.box="vertical") +
				guides(color=guide_legend(title="Country"))
}

#+ beta_phylo_plot5, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=4
if(length(unique(beta_q1p_nmds$sex))>1 && length(unique(beta_q1p_nmds$sex))<=8){
group_n <- length(unique(beta_q1p_nmds$sex))
beta_q1p_nmds %>%
			group_by(sex) %>%
			mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
			mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
			ungroup() %>%
			ggplot(., aes(x=NMDS1,y=NMDS2, color=sex)) +
				scale_color_manual(values=beta_colors[c(1:group_n)]) +
				geom_point(size=2) +
				geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
				theme_classic() +
				theme(legend.position="right", legend.box="vertical") +
				guides(color=guide_legend(title="Sex"))
}

#+ beta_phylo_plot6, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=4
if(length(unique(beta_q1p_nmds$sample_type))>1 && length(unique(beta_q1p_nmds$sample_type))<=8){
group_n <- length(unique(beta_q1p_nmds$sample_type))
beta_q1p_nmds %>%
			group_by(sample_type) %>%
			mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
			mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
			ungroup() %>%
			ggplot(., aes(x=NMDS1,y=NMDS2, color=sample_type)) +
				scale_color_manual(values=beta_colors[c(1:group_n)]) +
				geom_point(size=2) +
				geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
				theme_classic() +
				theme(legend.position="right", legend.box="vertical") +
				guides(color=guide_legend(title="Sample type"))
}

#' \newpage
#' ### 6.3.3 Functional beta diversity
#' The PERMANOVA analysis based on functional beta diversities indicates whether functional attributes of microbiomes
#' vary between metadata variables.

#+ beta_func, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide"
if(func == "yes"){
beta_q1f <- hillpair(count_table_cov_size_filt,q=1,dist=dist) %>%
				select(first,second,C) %>% #based on dissimilarity metric C
				as.data.frame() %>%
				pivot_wider(names_from = first, values_from = C) %>%
				column_to_rownames(var = "second") %>%
				as.matrix() %>%
				as.dist()
}

#+ beta_func_permanova_input, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide"
if(func == "yes"){
sample_table_adonis <- sample_table %>%
	filter(sample %in% labels(beta_q1f)) %>%
	arrange(sample) %>%
	mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
	select(sample,location,region,country,species,sex,sample_type) %>%
	select_if(~ length(unique(.)) > 1) %>% #remove columns with all-identical values
	column_to_rownames(var = "sample") %>%
	as.data.frame()
}

#+ beta_func_permanova, echo=FALSE, warning=FALSE, comments="", message=FALSE
if(func == "yes"){
	if(ncol(sample_table_adonis)>1){
		adonis2(formula=beta_q1f ~ ., data=sample_table_adonis[labels(beta_q1f),], permutations=999) %>%
				as.matrix() %>%
				kable()
	}else if(ncol(sample_table_adonis)==1){ # fix in case of a single variable
		adonis_matrix<-adonis2(formula=beta_q1f ~ sample_table_adonis[labels(beta_q1f),], permutations=999) %>%
				as.matrix()
		rownames(adonis_matrix)[1] <- colnames(sample_table_adonis)
		adonis_matrix %>%
				kable()
	}else{
		print("PERMANOVA was not conducted because of lack of metadata variability")
	}

}

#+ beta_func_nmds, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide"
if(func == "yes"){
beta_q1f_nmds <- beta_q1f %>%
				metaMDS(.,trymax = 500, k=2, verbosity=FALSE) %>%
				scores() %>%
				as_tibble(., rownames = "sample") %>%
				left_join(sample_table, by = join_by(sample == sample)) %>%
				mutate(location=paste0(round(longitude,2),"_",round(latitude,2)))
}

#+ beta_func_plot1, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=4
if(func == "yes"){
if(length(unique(beta_q1f_nmds$species))>1 && length(unique(beta_q1f_nmds$species))<=8){
group_n <- length(unique(beta_q1f_nmds$species))
beta_q1f_nmds %>%
			group_by(species) %>%
			mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
			mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
			ungroup() %>%
			ggplot(., aes(x=NMDS1,y=NMDS2, color=species)) +
				scale_color_manual(values=beta_colors[c(1:group_n)]) +
				geom_point(size=2) +
				geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
				theme_classic() +
				theme(legend.position="right", legend.box="vertical") +
				guides(color=guide_legend(title="Species"))
}
}
#+ beta_func_plot2, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=4
if(func == "yes"){
if(length(unique(beta_q1f_nmds$location))>1 && length(unique(beta_q1f_nmds$location))<=8){
group_n <- length(unique(beta_q1f_nmds$location))
beta_q1f_nmds %>%
			group_by(location) %>%
			mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
			mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
			ungroup() %>%
			ggplot(., aes(x=NMDS1,y=NMDS2, color=location)) +
				scale_color_manual(values=beta_colors[c(1:group_n)]) +
				geom_point(size=2) +
				geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
				theme_classic() +
				theme(legend.position="right", legend.box="vertical") +
				guides(color=guide_legend(title="Location"))
}
}
#+ beta_func_plot3, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=4
if(func == "yes"){
if(length(unique(beta_q1f_nmds$region))>1 && length(unique(beta_q1f_nmds$region))<=8){
group_n <- length(unique(beta_q1f_nmds$region))
beta_q1f_nmds %>%
			group_by(region) %>%
			mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
			mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
			ungroup() %>%
			ggplot(., aes(x=NMDS1,y=NMDS2, color=region)) +
				scale_color_manual(values=beta_colors[c(1:group_n)]) +
				geom_point(size=2) +
				geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
				theme_classic() +
				theme(legend.position="right", legend.box="vertical") +
				guides(color=guide_legend(title="Region"))
}
}
#+ beta_func_plot4, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=4
if(func == "yes"){
if(length(unique(beta_q1f_nmds$country))>1 && length(unique(beta_q1f_nmds$country))<=8){
group_n <- length(unique(beta_q1f_nmds$country))
beta_q1f_nmds %>%
			group_by(country) %>%
			mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
			mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
			ungroup() %>%
			ggplot(., aes(x=NMDS1,y=NMDS2, color=country)) +
				scale_color_manual(values=beta_colors[c(1:group_n)]) +
				geom_point(size=2) +
				geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
				theme_classic() +
				theme(legend.position="right", legend.box="vertical") +
				guides(color=guide_legend(title="Country"))
}
}
#+ beta_func_plot5, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=4
if(func == "yes"){
if(length(unique(beta_q1f_nmds$sex))>1 && length(unique(beta_q1f_nmds$sex))<=8){
group_n <- length(unique(beta_q1f_nmds$sex))
beta_q1f_nmds %>%
			group_by(sex) %>%
			mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
			mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
			ungroup() %>%
			ggplot(., aes(x=NMDS1,y=NMDS2, color=sex)) +
				scale_color_manual(values=beta_colors[c(1:group_n)]) +
				geom_point(size=2) +
				geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
				theme_classic() +
				theme(legend.position="right", legend.box="vertical") +
				guides(color=guide_legend(title="Sex"))
}
}
#+ beta_func_plot6, echo=FALSE, warning=FALSE, comments="", message=FALSE, results="hide", fig.height=4
if(func == "yes"){
if(length(unique(beta_q1f_nmds$sample_type))>1 && length(unique(beta_q1f_nmds$sample_type))<=8){
group_n <- length(unique(beta_q1f_nmds$sample_type))
beta_q1f_nmds %>%
			group_by(sample_type) %>%
			mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
			mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
			ungroup() %>%
			ggplot(., aes(x=NMDS1,y=NMDS2, color=sample_type)) +
				scale_color_manual(values=beta_colors[c(1:group_n)]) +
				geom_point(size=2) +
				geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
				theme_classic() +
				theme(legend.position="right", legend.box="vertical") +
				guides(color=guide_legend(title="Sample type"))
}
}
